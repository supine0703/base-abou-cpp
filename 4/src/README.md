
> 在封装 `lib`(c++20) 时 部分参考了 `sgi stl` 和 `gnu stl` 

### cpp 封装类进阶使用关键字

#### inline

- 作用：建议内联，将逻辑简单（通常建议没有 分支、循环）且代码量少的函数，编译展开而不是调用函数
- 注意：因为作用于编译期，需要在编译时可见，即：放在头文件；同时类内部实现成员函数，默认添加内联建议
- 封装库技巧：虽然使用虚函数，可以减少重复代码，如果从效率的角度出发，应该避免使用虚函数，因为无法内联展开


#### constexpr

- 作用：编译阶段处理，以优化运行时；可以修饰函数或者常量
- 修饰常量：左值，但是不可修改，可以用于编译时期的运算
- 修饰函数：可以返回右值，隐式申明内联展开


#### explicit 

- 作用：用于防止构造函数或转换运算符进行隐式转换；它确保只有在明确调用时才会进行类型转换
- 括号内的表达式用于在编译时进行条件检查：
  - 如果表达式为 true，则构造函数或转换运算符被标记为 explicit；
  - 否则，不被标记为 explicit

```cpp
class MyClass {
public:
    explicit MyClass(int value) { /* ... */ }
};

void func(MyClass obj) { /* ... */ }

int main() {
    MyClass obj1 = 10; // 错误：隐式转换被禁止
    MyClass obj2(10);  // 正确：显式调用构造函数
    func(10);          // 错误：隐式转换被禁止
    func(MyClass(10)); // 正确：显式调用构造函数
    return 0;
}
```


#### noexcept

- 作用：用于指定一个函数不会抛出异常；如果一个函数被标记为 noexcept，编译器可以进行优化，因为它知道这个函数不会抛出异常
- 括号内的表达式用于在编译时进行条件检查
  - 如果表达式为 true，则函数被标记为 noexcept；
  - 否则，不被标记为 noexcept

```cpp
void func() noexcept { /* 这个函数不会抛出异常 */ }

void func2() noexcept(false) { /* 这个函数可能会抛出异常 */ }
```


#### requires

- c++ >= 20
- 作用：用于指定模板的约束条件。它允许你在模板定义中添加条件，以确保模板参数满足特定的要求。
- 括号内的表达式用于在编译时进行条件检查：
  - 如果表达式为 true，则模板实例化成功；
  - 否则，编译失败

```cpp
template <typename T>
requires std::is_integral_v<T>
void func(T value) {
    // 这个函数只接受整数类型的参数
}
```


#### volatile
- 作用：用于声明可能会被程序外部因素修改的变量；它告诉编译器，这个变量的值可能会随时改变，因此编译器不应该对其进行某些优化。
